! ===========================================================================
Module WMAP_teeebb_lowl

    ! This code calculates the likelihood function of Q/U
    ! polarization for EE signal plus noise.
    !
    ! Use combined 3yr data.
    ! - Combined Ninv and weighted maps have been generated by
    ! maps/weight_degrade_coadd_p2.f90
    !
    ! - NinvPlNinv has been generated by
    ! ninv/generate_ninvplninv_r3_p2.f90
    !
    ! E. Komatsu, October 4, 2005
    ! Incorporated into likelihood code October 7th RB.
    ! BB has been added, November 6th EK.
    !
    ! - Implementation of David's likelihood
    ! Ek, December 16, 2005
    !
    ! << MODIFICATION HISTORY AFTER RELEASE on March 16, 2006 >>
    !
    ! E. Komatsu, June 18, 2006
    ! -- Use alm^tt from the released 3yr ILC map(wmap_ilc_3yr_v2.fits)
    ! -- Marginalization over the polarized foreground
    !
    ! E. Komatsu, February 3, 2007
    ! -- 5-yr version
    ! -- Use double-precision LAPACK
    !
    ! E. Komatsu, March 5, 2009
    ! -- Changed the declaration of ninvplninv2 to real(8)
    !    [thanks to Antony Lewis]
    ! -- Changed the orders of do-loops for a better performance
    !    [thanks to Raphael Flauger]
    !
    ! E. Komatsu, December 20, 2009
    ! -- 7-yr version
    ! ===========================================================================

    Implicit None
    Private
    Public :: teeebb_lowl_like_setup, teeebb_lowl_likelihood, teeebb_pixlike_dof

    Integer :: nsmax, nlmax, np, mp
#ifdef OPTIMIZE
    Real(8), Allocatable, Dimension(:) :: xxx, yyy
    Real(8), Allocatable, Dimension(:, :) :: ninvplninv2
    Real, Allocatable, Dimension(:, :, :), Target :: ninvplninv3
#else
    Real, Allocatable, Dimension(:, :, :, :), Target :: ninvplninv
#endif
    Integer, Allocatable, Dimension(:) :: ngood
    Real(8), Allocatable, Dimension(:, :) :: Dp0
    Real(8), Allocatable, Dimension(:) :: m_r3, w_r3, p_r3, f_r3, zzz
    Complex, Allocatable, Dimension(:, :), Target :: alm_tt, NinvY
    Real, Allocatable, Dimension(:) :: wl
#ifdef MARGINALIZE_OVER_LOWELL_POL_TEMPLATE
    Real :: sig_temp = 0.1
#endif

Contains
    !===========================================
    Subroutine teeebb_lowl_like_setup
        !===========================================

        Use wmap_util
        Use wmap_options, Only: WMAP_data_dir, teeebb_filename, eebbdir, teeebb_maskfile

        Implicit None

        Character(Len=2) :: rlz
        Integer, Parameter :: ires = 3
        Real, Dimension(:), Allocatable :: T, N, Mask_R3
        Character(Len=3) :: da(10), sband
        Integer :: ReadStatus
        Character(Len=256) :: qfile, ufile
        !    teeebb_maskfile, teeebb_filename(0:9), eebbdir

        Integer :: dum, nsmax, nlmax, l, ip, jp, m, lun, stat, i, j, k
        Real, Allocatable, Dimension(:, :), Target :: NinvQUr3
        Logical :: yes

        Complex(Kind=4), Dimension(:, :), Pointer :: Cptr2
        Real(Kind=4), Dimension(:, :), Pointer :: Rptr2
        Real(Kind=4), Dimension(:, :, :), Pointer :: Rptr3

        Include 'read_archive_map.fh'
        Include 'read_fits.fh'

#ifdef TIMING
        Call wmap_timing_start('teeebb_lowl_like_setup')
#endif

        !------------------------------
        ! Set initial parameters
        !-----------------------------

        da = (/ 'K1', 'Ka', 'Q1', 'Q2', 'V1', 'V2', 'W1', 'W2', 'W3', 'W4' /)
        da(2) = 'Ka1'


        nsmax = 2 ** ires
        nlmax = 3 * nsmax - 1 ! use Nyquist sampling rather than 2*nsmax
        np = 12 * nsmax ** 2


        !------------------------------
        ! read in res3 mask
        !------------------------------

        Allocate(Mask_R3(0:np-1))
        Allocate(T(0:np-1))
        Allocate(N(0:np-1))

        Inquire(File=teeebb_maskfile, Exist=yes)
        If ( .Not. yes) Then
            Write(*,*) "teeebb maskfile not found", Trim(teeebb_maskfile)
        End If
        Call READ_ARCHIVE_MAP(teeebb_maskfile, T, Mask_R3, dum, ReadStatus)
        If (ReadStatus /= 0) Then
            Print *, 'unable to read in mask', Trim(teeebb_maskfile)
            Stop
        End If

        Allocate(ngood(0:np-1))
        mp = 0
        Do ip = 0, np - 1
            If (Mask_R3(ip) /= 0) Then
                ngood(mp) = ip

                mp = mp + 1

            End If
        End Do

        !------------------------------
        ! read in N^{-1}P_l N^{-1} at res3
        !------------------------------

#ifdef OPTIMIZE

        Allocate(ninvplninv2(mp*(2*mp+1), 2*(nlmax-1)), Stat=Stat)
        If (stat .Ne. 0) Then
            Print *, 'Memory allocation error for ninvplninv2'
            Stop
        End If

        Allocate(ninvplninv3(0:nlmax, 0:2*np-1, 0:2*np-1), Stat=Stat)
        If (stat .Ne. 0) Then
            Print *, 'Memory allocation error for ninvplninv3'
            Stop
        End If
        Rptr3 => ninvplninv3(:, :, :)

        Call Read_FITS_Real_3D(teeebb_filename(0), Rptr3, stat)
        If (stat .Ne. 0) Then
            Print *, 'Error ', stat, ' while reading ', Trim(teeebb_filename(0))
            Stop
        End If

        k = 1
        ! --- original
        !	do i = 0,2*mp-1
        !	do j = i,2*mp-1
        ! --- RF
        Do j = 0, 2 * mp - 1
            Do i = 0, j
                ! ---
                ip = ngood(Mod(i, mp)) + np * (i/mp)
                jp = ngood(Mod(j, mp)) + np * (j/mp)

                ninvplninv2(k, 1:nlmax-1) = ninvplninv3(2:nlmax, ip, jp)
                k = k + 1

            End Do
        End Do

        Call Read_FITS_Real_3D(teeebb_filename(1), Rptr3, stat)
        If (stat .Ne. 0) Then
            Print *, 'Error ', stat, ' while reading ', Trim(teeebb_filename(1))
            Stop
        End If

        k = 1
        ! --- original
        !	do i = 0,2*mp-1
        !	do j = i,2*mp-1
        ! --- RF
        Do j = 0, 2 * mp - 1
            Do i = 0, j
                ! ---
                ip = ngood(Mod(i, mp)) + np * (i/mp)
                jp = ngood(Mod(j, mp)) + np * (j/mp)

                ninvplninv2(k, nlmax:2*(nlmax-1)) = ninvplninv3(2:nlmax, ip, jp)
                k = k + 1

            End Do
        End Do

        Deallocate(ninvplninv3)

        Allocate(xxx(2*(nlmax-1)))
        Allocate(yyy(mp*(2*mp+1)))

#else

        Allocate(ninvplninv(0:nlmax, 0:2*np-1, 0:2*np-1, 2), Stat=Stat)
        If (stat .Ne. 0) Then
            Print *, 'Memory allocation error for ninvplninv'
            Stop
        End If

        Rptr3 => ninvplninv(:, :, :, 1)
        Call Read_FITS_Real_3D(teeebb_filename(0), Rptr3, stat)
        If (stat .Ne. 0) Then
            Print *, 'Error ', stat, ' while reading ', Trim(teeebb_filename(0))
            Stop
        End If

        Rptr3 => ninvplninv(:, :, :, 2)
        Call Read_FITS_Real_3D(teeebb_filename(1), Rptr3, stat)
        If (stat .Ne. 0) Then
            Print *, 'Error ', stat, ' while reading ', Trim(teeebb_filename(1))
            Stop
        End If

#endif

        !------------------------------
        ! read in N^{-1} at res3
        !------------------------------

        Allocate(NinvQUr3(0:1535, 0:1535), Stat=Stat)
        If (stat .Ne. 0) Then
            Print *, 'Memory allocation error for NinvQUr3'
            Stop
        End If

        Rptr2 => NinvQUr3
        Call Read_FITS_Real_2D(teeebb_filename(2), Rptr2, stat)
        If (stat .Ne. 0) Then
            Print *, 'Error ', stat, ' while reading ', Trim(teeebb_filename(2))
            Stop
        End If

        !------------------------------
        ! read in maps at res3
        !------------------------------

        Allocate(w_r3(0:2*mp-1), m_r3(0:2*mp-1), p_r3(0:2*mp-1), Stat=Stat)
        Allocate(zzz(0:2*mp-1))
        If (stat .Ne. 0) Then
            Print *, 'Memory allocation error for w_r3, m_r3, or p_r3'
            Stop
        End If
        qfile = teeebb_filename(3)
        Call READ_ARCHIVE_MAP(qfile, T, N, np, ReadStatus)
        If (ReadStatus /= 0) Then
            Print *, 'unable to read in ' // Trim(qfile)
            Stop
        End If

        Do ip = 0, mp - 1
            w_r3(ip) = T(ngood(ip)) * Mask_R3(ngood(ip))
        End Do

        ufile = teeebb_filename(4)
        Call READ_ARCHIVE_MAP(ufile, T, N, np, ReadStatus)
        If (ReadStatus /= 0) Then
            Print *, 'unable to read in ' // Trim(ufile)
            Stop
        End If

        Do ip = 0, mp - 1
            w_r3(mp+ip) = T(ngood(ip)) * Mask_R3(ngood(ip))
        End Do

        Allocate(Dp0(0:2*mp-1, 0:2*mp-1), Stat=Stat)
        If (stat .Ne. 0) Then
            Print *, 'Memory allocation error for Dp0'
            Stop
        End If
        ! --- original
        !  do ip=0,mp-1
        !     do jp=0,mp-1
        ! --- RF
        Do jp = 0, mp - 1
            Do ip = 0, mp - 1
                ! ---
                Dp0(ip, jp) = NinvQUr3(ngood(ip), ngood(jp))
                Dp0(ip, mp+jp) = NinvQUr3(ngood(ip), np+ngood(jp))
                Dp0(mp+ip, jp) = NinvQUr3(np+ngood(ip), ngood(jp))
                Dp0(mp+ip, mp+jp) = NinvQUr3(np+ngood(ip), np+ngood(jp))
            End Do
        End Do

        !------------------------------
        ! read in FG templates at res3
        !------------------------------


#ifdef MARGINALIZE_OVER_LOWELL_POL_TEMPLATE
        Allocate(f_r3(0:2*mp-1), Stat=Stat)
        If (stat .Ne. 0) Then
            Print *, 'Memory allocation error for f_r3'
            Stop
        End If
        qfile = teeebb_filename(7)
        Call READ_ARCHIVE_MAP(qfile, T, N, np, ReadStatus)
        If (ReadStatus /= 0) Then
            Print *, 'unable to read in ' // Trim(qfile)
            Stop
        End If

        Do ip = 0, mp - 1
            f_r3(ip) = T(ngood(ip)) * Mask_R3(ngood(ip))
        End Do

        ufile = teeebb_filename(8)
        Call READ_ARCHIVE_MAP(ufile, T, N, np, ReadStatus)
        If (ReadStatus /= 0) Then
            Print *, 'unable to read in ' // Trim(ufile)
            Stop
        End If

        Do ip = 0, mp - 1
            f_r3(mp+ip) = T(ngood(ip)) * Mask_R3(ngood(ip))
        End Do
#endif

        !------------------------------
        ! read in alm_tt
        !------------------------------
        Allocate(alm_tt(0:nlmax, 0:nlmax), Stat=Stat)
        If (stat .Ne. 0) Then
            Print *, 'Memory allocation error for alm_tt'
            Stop
        End If
        Call get_free_lun(lun)
        Open(lun, File=teeebb_filename(5), Status='old')
        Do l = 0, nlmax
            Do m = 0, l
                Read(lun,*) alm_tt(l, m)
            End Do
        End Do
        Close(lun)

        !------------------------------
        ! read in Ninv Y
        !------------------------------
        Allocate(NinvY(0:1535, 300), Stat=Stat)
        If (stat .Ne. 0) Then
            Print *, 'Memory allocation error for NinvY'
            Stop
        End If

        Cptr2 => NinvY
        Call Read_FITS_Complex_2D_LM(teeebb_filename(6), Cptr2, stat, IndFmt=2)
        If (stat .Ne. 0) Then
            Print *, 'Error ', stat, ' while reading ', Trim(teeebb_filename(6))
            Stop
        End If

        !
        ! read in pixel window
        !
        Allocate(wl(0:nlmax))
        Call get_free_lun(lun)
        Open(lun, File=teeebb_filename(9), Status='old')
        Do l = 0, nlmax
            Read(lun,*) wl(l)
        End Do
        Close(lun)

        Deallocate(T, N, Mask_R3)
        Deallocate(NinvQUr3)

#ifdef TIMING
        Call wmap_timing_end()
#endif

    End Subroutine teeebb_lowl_like_setup


    Function teeebb_pixlike_dof()
        Integer :: teeebb_pixlike_dof
        teeebb_pixlike_dof = 2 * mp
    End Function teeebb_pixlike_dof

    !===========================================
    Subroutine teeebb_lowl_likelihood(nlmaxin, clttin, cltein, cleein, clbbin, chisq_r3, lndet)
        !=======================================

        Use wmap_util
        Use wmap_options, Only: teeebb_pixlike_lndet_offset

        Implicit None

        Real(8), Dimension(2:*), Intent(In) :: clttin, cltein, cleein, clbbin
        Real(8), Intent(Out) :: lndet, chisq_r3 ! like
        Integer, Intent(In) :: nlmaxin
#ifndef OPTIMIZE
        Real(8), Allocatable, Dimension(:, :) :: NinvSNinv
        Real(8), Allocatable, Dimension(:, :) :: CQU
#endif
        Real(8), External :: DDOT
        Real(8), Allocatable, Dimension(:, :) :: Dp
        Real(8), Allocatable, Dimension(:) :: clee, clbb, cltt, clte
        Integer :: ip, jp, nlmax, info, l, m, i, k
        Integer :: t_start, t_end, crate, cmax
        Real :: Omega_pix

#ifdef TIMING
        Call wmap_timing_start('teeebb_lowl_likelihood')
#endif

        nlmax = 23
        Omega_pix = 3.14159 / (3.*8.**2.)
        If (nlmaxin .Ne. nlmax) Then
            Write(*,*) "need nlmax", nlmax, ", in teeebb likelihood, currently", nlmaxin
            Stop
        End If

        Allocate(cltt(0:nlmax), clte(0:nlmax), clee(0:nlmax), clbb(0:nlmax))
        cltt(0:1) = 0.
        clte(0:1) = 0.
        clee(0:1) = 0.
        clbb(0:1) = 0.
        Do l = 2, nlmax
            cltt(l) = clttin(l) / Dble(l*(l+1)) * (2.*3.14159) * 1.d-6 * wl(l) ** 2.
            clte(l) = cltein(l) / Dble(l*(l+1)) * (2.*3.14159) * 1.d-6 * wl(l) ** 2.
            clee(l) = cleein(l) / Dble(l*(l+1)) * (2.*3.14159) * 1.d-6 * wl(l) ** 2.
            clbb(l) = clbbin(l) / Dble(l*(l+1)) * (2.*3.14159) * 1.d-6 * wl(l) ** 2.
        End Do

        !------------------------------
        ! compute [N^{-1}S N^{-1} + N^{-1}]^{-1}
        !------------------------------
        Allocate(Dp(0:2*mp-1, 0:2*mp-1))

        lndet = 0d0

#ifdef OPTIMIZE
        !! MRN

        Do l = 2, nlmax
            xxx(l-1) = clee(l) - clte(l) ** 2. / cltt(l)
            xxx(l+nlmax-2) = clbb(l)
        End Do

        Call DGEMV('N', mp*(2*mp+1), 2*(nlmax-1), 1.d0, ninvplninv2, &
            mp*(2*mp+1), xxx, 1, 0.d0, yyy, 1)

        k = 1
        ! --- original ---
        !	do ip = 0,2*mp-1
        !	do jp = ip,2*mp-1
        ! --- RF
        Do jp = 0, 2 * mp - 1
            Do ip = 0, jp
                ! ---
                Dp(ip, jp) = Dp0(ip, jp) &
#ifdef MARGINALIZE_OVER_LOWELL_POL_TEMPLATE
                + sig_temp ** 2 * f_r3(ip) * f_r3(jp) &
#endif
                + yyy(k)
                k = k + 1
            End Do
        End Do

#else
        !
        ! fill only the upper triangular part of N^{-1}SN^{-1}.
        ! add the foreground error term.
        !
        Allocate(NinvSNinv(0:2*mp-1, 0:2*mp-1))
        Allocate(CQU(0:2*mp-1, 0:2*mp-1))
        NinvSNinv = 0.
        ! --- original
        !  do ip=0,mp-1
        !     do jp=ip,mp-1
        ! --- RF
        Do jp = 0, mp - 1
            Do ip = 0, jp
                ! ---
                NinvSNinv(ip, jp) = &
#ifdef MARGINALIZE_OVER_LOWELL_POL_TEMPLATE
                sig_temp ** 2. * f_r3(ip) * f_r3(jp) &
#endif
                + DDOT(nlmax-1, clee(2:)-clte(2:)**2./cltt(2:), 1, Dble(ninvplninv(2:, ngood(ip), ngood(jp), 1)), 1) &
                    + DDOT(nlmax-1, clbb(2:), 1, Dble(ninvplninv(2:, ngood(ip), ngood(jp), 2)), 1)

                NinvSNinv(ip, mp+jp) = &
#ifdef MARGINALIZE_OVER_LOWELL_POL_TEMPLATE
                sig_temp ** 2. * f_r3(ip) * f_r3(mp+jp) &
#endif
                + DDOT(nlmax-1, clee(2:)-clte(2:)**2./cltt(2:), 1, Dble(ninvplninv(2:, ngood(ip), np+ngood(jp), 1)), 1) &
                    + DDOT(nlmax-1, clbb(2:), 1, Dble(ninvplninv(2:, ngood(ip), np+ngood(jp), 2)), 1)

                NinvSNinv(mp+ip, mp+jp) = &
#ifdef MARGINALIZE_OVER_LOWELL_POL_TEMPLATE
                sig_temp ** 2. * f_r3(mp+ip) * f_r3(mp+jp) &
#endif
                + DDOT(nlmax-1, clee(2:)-clte(2:)**2./cltt(2:), 1, Dble(ninvplninv(2:, np+ngood(ip), np+ngood(jp), 1)), 1) &
                    + DDOT(nlmax-1, clbb(2:), 1, Dble(ninvplninv(2:, np+ngood(ip), np+ngood(jp), 2)), 1)
            End Do
            ! --- original
            !   do jp=0,ip-1
            ! --- RF
        End Do

        Do jp = 0, mp - 1
            Do ip = jp + 1, mp - 1
                !---
                NinvSNinv(ip, mp+jp) = NinvSNinv(ip, mp+jp)  &
#ifdef MARGINALIZE_OVER_LOWELL_POL_TEMPLATE
                + sig_temp ** 2. * f_r3(ip) * f_r3(mp+jp) &
#endif
                + DDOT(nlmax-1, clee(2:)-clte(2:)**2./cltt(2:), 1, Dble(ninvplninv(2:, ngood(ip), np+ngood(jp), 1)), 1) &
                    + DDOT(nlmax-1, clbb(2:), 1, Dble(ninvplninv(2:, ngood(ip), np+ngood(jp), 2)), 1)
            End Do

        End Do

        Dp = Dp0 + NinvSNinv

        Deallocate(NinvSNinv)

#endif

#ifdef TIMING
        Call wmap_timing_checkpoint('finished Dp')
#endif

        Call DPOTRF('U', 2*mp, Dp, 2*mp, info)
        If (info .Ne. 0) Then
            Call wmap_likelihood_error('teeebb: bad dpotrf', info)
            chisq_r3 = 0d0
            lndet = 0d0
            Return
        End If

#ifdef TIMING
        Call wmap_timing_checkpoint('finished spotrf')
#endif

        Do ip = 0, 2 * mp - 1
            lndet = lndet + 2. * Log(Real(Dp(ip, ip)))
        End Do

#ifndef OPTIMIZE
        Call DPOTRI('U', 2*mp, Dp, 2*mp, info)
#endif

#ifdef TIMING
        Call wmap_timing_checkpoint('finished dpotri')
#endif

        If (info .Ne. 0) Then
            Call wmap_likelihood_error('teeebb: bad dpotri', info)
            chisq_r3 = 0d0
            lndet = 0d0
            Return
        End If

#ifndef OPTIMIZE
        CQU(:, :) = Dp
        Deallocate(Dp)
#endif


        !-----------------------------------
        ! calculate the predicted QU at res3
        !-----------------------------------
        p_r3 = 0.

        Do ip = 0, mp - 1
            i = 3
            Do l = 2, 23
                i = i + 1
                p_r3(ip) = p_r3(ip) &
                    + clte(l) / cltt(l) * wl(l) * alm_tt(l, 0) * NinvY(ngood(ip), i)
                p_r3(ip+mp) = p_r3(ip+mp) &
                    + clte(l) / cltt(l) * wl(l) * alm_tt(l, 0) * NinvY(ngood(ip)+np, i)
                Do m = 1, l
                    i = i + 1
                    p_r3(ip) = p_r3(ip) &
                        + clte(l) / cltt(l) * wl(l) * (alm_tt(l, m)*NinvY(ngood(ip), i) &
                        + Conjg(alm_tt(l, m)*NinvY(ngood(ip), i)))
                    p_r3(ip+mp) = p_r3(ip+mp) &
                        + clte(l) / cltt(l) * wl(l) * (alm_tt(l, m)*NinvY(ngood(ip)+np, i) & 
                        + Conjg(alm_tt(l, m)*NinvY(ngood(ip)+np, i)))
                End Do
            End Do
        End Do

#ifdef OPTIMIZE

        m_r3 = w_r3 - p_r3
        Call DPOTRS('U', 2*mp, 1, Dp, 2*mp, m_r3, 2*mp, info)
	!chisq_r3 = DDOT(2*mp,m_r3,1,w_r3-p_r3,1)
        zzz = w_r3 - p_r3
        chisq_r3 = Sum(m_r3*zzz)
#else

        Call DSYMV('U', 2*mp, 1.d0, CQU(:, :), 2*mp, w_r3-p_r3, 1, 0.d0, m_r3, 1)
        chisq_r3 = DDOT(2*mp, m_r3, 1, w_r3-p_r3, 1)

        Deallocate(CQU)

#endif

        chisq_r3 = chisq_r3 / 2d0
        lndet = (lndet-teeebb_pixlike_lndet_offset) / 2d0

#ifdef TIMING
        Call wmap_timing_end()
#endif

    End Subroutine teeebb_lowl_likelihood

End Module WMAP_teeebb_lowl
