! ===========================================================================
Module WMAP_tetbeebbeb_lowl

    ! This code calculates the likelihood function of Q/U
    ! polarization for TE/TB/EE/BB/EB signal plus noise.
    !
    ! Use combined 3yr data.
    ! - Combined Ninv and weighted maps have been generated by
    ! maps/weight_degrade_coadd_p2.f90
    !
    ! - NinvPlNinv has been generated by
    ! ninv/generate_ninvplninv_r3_p2.f90
    !
    ! E. Komatsu, October 4, 2005
    ! Incorporated into likelihood code October 7th RB.
    ! BB has been added, November 6th EK.
    !
    ! - Implementation of David's likelihood
    ! Ek, December 16, 2005
    !
    ! << MODIFICATION HISTORY AFTER RELEASE on March 16, 2006 >>
    !
    ! E. Komatsu, June 18, 2006
    ! -- Use alm^tt from the released 3yr ILC map(wmap_ilc_3yr_v2.fits)
    ! -- Marginalization over the polarized foreground
    !
    ! E. Komatsu, February 3, 2007
    ! -- 5-yr version
    ! -- Use double-precision LAPACK
    !
    ! E. Komatsu, December 25, 2007
    ! -- TB & EB have been added as optional
    ! -- Foreground marginalization done to N^{-1} outside of this code
    !
    ! E. Komatsu, March 5, 2009
    ! -- Changed the declaration of ninvplninv2 to real(8)
    !    [thanks to Antony Lewis]
    ! -- Changed the orders of do-loops for a better performance
    !    [thanks to Raphael Flauger]
    !
    ! E. Komatsu, December 20, 2009
    ! -- 7-yr version
    ! ===========================================================================

    Implicit None
    Private
    Public :: tetbeebbeb_lowl_like_setup, tetbeebbeb_lowl_likelihood, tetbeebbeb_pixlike_dof

    Integer :: nsmax, nlmax, np, mp
#ifdef OPTIMIZE
    Real(8), Allocatable, Dimension(:) :: xxx, yyy
    Real(8), Allocatable, Dimension(:, :) :: ninvplninv2
    Real, Allocatable, Dimension(:, :, :), Target :: ninvplninv3
#else
    Real, Allocatable, Dimension(:, :, :, :), Target :: ninvplninv
#endif
    Integer, Allocatable, Dimension(:) :: ngood
    Real(8), Allocatable, Dimension(:, :) :: Dp0
    Real(8), Allocatable, Dimension(:) :: m_r3, w_r3, p_r3, f_r3, zzz
    Complex, Allocatable, Dimension(:, :), Target :: alm_tt, NinvYe, NinvYb
    Real, Allocatable, Dimension(:) :: wl
!!$  REAL :: sig_temp = 0.01
    Real :: sig_temp = 0.0 ! FG marginalization done outside of this code
Contains

    !===========================================
    Subroutine tetbeebbeb_lowl_like_setup
        !===========================================

        Use wmap_util
        Use wmap_options, Only: WMAP_data_dir, teeebb_maskfile

        Implicit None

        Character(Len=2) :: rlz
        Integer, Parameter :: ires = 3
        Real, Dimension(:), Allocatable :: T, N, Mask_R3
        Character(Len=3) :: da(10), sband
        Integer :: ReadStatus
        Character(Len=256) :: qfile, ufile, maskfile, filename(0:12), tetbeebbebdir

        Integer :: dum, nsmax, nlmax, l, ip, jp, m, lun, stat, i, j, k
        Real, Allocatable, Dimension(:, :), Target :: NinvQUr3
        Logical :: yes

        Complex(Kind=4), Dimension(:, :), Pointer :: Cptr2
        Real(Kind=4), Dimension(:, :), Pointer :: Rptr2
        Real(Kind=4), Dimension(:, :, :), Pointer :: Rptr3

        Include 'read_archive_map.fh'
        Include 'read_fits.fh'

#ifdef TIMING
        Call wmap_timing_start('tetbeebbeb_lowl_like_setup')
#endif

        !------------------------------
        ! Set initial parameters
        !-----------------------------

        da = (/ 'K1', 'Ka', 'Q1', 'Q2', 'V1', 'V2', 'W1', 'W2', 'W3', 'W4' /)
        da(2) = 'Ka1'


        nsmax = 2 ** ires
        nlmax = 3 * nsmax - 1 ! use Nyquist sampling rather than 2*nsmax
        np = 12 * nsmax ** 2

        
        tetbeebbebdir = Trim(WMAP_data_dir) // 'lowlP/std/'
        filename(0) = Trim(tetbeebbebdir) // 'masked_ee_ninvplninv_qu_r3_corrected_9yr.KaQV.fits'
        filename(1) = Trim(tetbeebbebdir) // 'masked_bb_ninvplninv_qu_r3_corrected_9yr.KaQV.fits'
        filename(10) = Trim(tetbeebbebdir) // 'tbeb/masked_eb_ninvplninv_qu_r3_corrected_9yr.KaQV.fits'
        filename(11) = Trim(tetbeebbebdir) // 'tbeb/masked_be_ninvplninv_qu_r3_corrected_9yr.KaQV.fits'

        filename(2) = Trim(tetbeebbebdir) // 'masked_ninv_qu_r3_corrected_9yr.KaQV.fits'
        filename(3) = Trim(tetbeebbebdir) // 'wt_r3_9yr.KaQV.map_q'
        filename(4) = Trim(tetbeebbebdir) // 'wt_r3_9yr.KaQV.map_u'
        filename(6) = Trim(tetbeebbebdir) // 'masked_ninvy_e_qu_r3_corrected_9yr.KaQV.fits'
        filename(12) = Trim(tetbeebbebdir) // 'tbeb/masked_ninvy_b_qu_r3_corrected_9yr.KaQV.fits'

        filename(5) = Trim(WMAP_data_dir) // 'lowlP/alm_tt_fs_r9_ilc_nopixwin_9yr.dat'
        filename(9) = Trim(WMAP_data_dir) // 'healpix_data/pixel_window_n0008.txt'

        !------------------------------
        ! read in res3 mask
        !------------------------------

        Allocate(Mask_R3(0:np-1))
        Allocate(T(0:np-1))
        Allocate(N(0:np-1))

        maskfile=teeebb_maskfile
        Inquire(File=maskfile, Exist=yes)
        If ( .Not. yes) Then
            Write(*,*) "tetbeebbeb maskfile not found", Trim(maskfile)
        End If
        Call READ_ARCHIVE_MAP(maskfile, T, Mask_R3, dum, ReadStatus)
        If (ReadStatus /= 0) Then
            Print *, 'unable to read in mask', Trim(maskfile)
            Stop
        End If

        Allocate(ngood(0:np-1))
        mp = 0
        Do ip = 0, np - 1
            If (Mask_R3(ip) /= 0) Then
                ngood(mp) = ip

                mp = mp + 1

            End If
        End Do

        !------------------------------
        ! read in N^{-1}P_l N^{-1} at res3
        !------------------------------

#ifdef OPTIMIZE

        Allocate(ninvplninv2(mp*(2*mp+1), 4*(nlmax-1)), Stat=Stat)
        If (stat .Ne. 0) Then
            Print *, 'Memory allocation error for ninvplninv2'
            Stop
        End If

        Allocate(ninvplninv3(0:nlmax, 0:2*np-1, 0:2*np-1), Stat=Stat)
        If (stat .Ne. 0) Then
            Print *, 'Memory allocation error for ninvplninv3'
            Stop
        End If
        Rptr3 => ninvplninv3(:, :, :)

        Call Read_FITS_Real_3D(filename(0), Rptr3, stat)
        If (stat .Ne. 0) Then
            Print *, 'Error ', stat, ' while reading ', Trim(filename(0))
            Stop
        End If

        k = 1
        ! --- original
        !	do i = 0,2*mp-1
        !	do j = i,2*mp-1
        ! --- RF
        Do j = 0, 2 * mp - 1
            Do i = 0, j
                ! ---
                ip = ngood(Mod(i, mp)) + np * (i/mp)
                jp = ngood(Mod(j, mp)) + np * (j/mp)

                ninvplninv2(k, 1:nlmax-1) = ninvplninv3(2:nlmax, ip, jp)
                k = k + 1

            End Do
        End Do

        Call Read_FITS_Real_3D(filename(1), Rptr3, stat)
        If (stat .Ne. 0) Then
            Print *, 'Error ', stat, ' while reading ', Trim(filename(1))
            Stop
        End If

        k = 1
        ! --- original
        !	do i = 0,2*mp-1
        !	do j = i,2*mp-1
        ! --- RF
        Do j = 0, 2 * mp - 1
            Do i = 0, j
                ! ---
                ip = ngood(Mod(i, mp)) + np * (i/mp)
                jp = ngood(Mod(j, mp)) + np * (j/mp)

                ninvplninv2(k, nlmax:2*(nlmax-1)) = ninvplninv3(2:nlmax, ip, jp)
                k = k + 1

            End Do
        End Do

        Call Read_FITS_Real_3D(filename(10), Rptr3, stat)
        If (stat .Ne. 0) Then
            Print *, 'Error ', stat, ' while reading ', Trim(filename(0))
            Stop
        End If

        k = 1
        ! --- original
        !       do i = 0,2*mp-1
        !       do j = i,2*mp-1
        ! --- RF
        Do j = 0, 2 * mp - 1
            Do i = 0, j
                ! ---
                ip = ngood(Mod(i, mp)) + np * (i/mp)
                jp = ngood(Mod(j, mp)) + np * (j/mp)

                ninvplninv2(k, 2*nlmax-1:3*(nlmax-1)) = ninvplninv3(2:nlmax, ip, jp)
                k = k + 1

            End Do
        End Do

        Call Read_FITS_Real_3D(filename(11), Rptr3, stat)
        If (stat .Ne. 0) Then
            Print *, 'Error ', stat, ' while reading ', Trim(filename(1))
            Stop
        End If

        k = 1
        ! --- original
        !	do i = 0,2*mp-1
        !	do j = i,2*mp-1
        ! --- RF
        Do j = 0, 2 * mp - 1
            Do i = 0, j
                ! ---
                ip = ngood(Mod(i, mp)) + np * (i/mp)
                jp = ngood(Mod(j, mp)) + np * (j/mp)

                ninvplninv2(k, 3*nlmax-2:4*(nlmax-1)) = ninvplninv3(2:nlmax, ip, jp)
                k = k + 1

            End Do
        End Do

        Deallocate(ninvplninv3)

        Allocate(xxx(4*(nlmax-1)))
        Allocate(yyy(mp*(2*mp+1)))

#else

        Allocate(ninvplninv(0:nlmax, 0:2*np-1, 0:2*np-1, 4), Stat=Stat)
        If (stat .Ne. 0) Then
            Print *, 'Memory allocation error for ninvplninv'
            Stop
        End If

        Rptr3 => ninvplninv(:, :, :, 1)
        Call Read_FITS_Real_3D(filename(0), Rptr3, stat)
        If (stat .Ne. 0) Then
            Print *, 'Error ', stat, ' while reading ', Trim(filename(0))
            Stop
        End If

        Rptr3 => ninvplninv(:, :, :, 2)
        Call Read_FITS_Real_3D(filename(1), Rptr3, stat)
        If (stat .Ne. 0) Then
            Print *, 'Error ', stat, ' while reading ', Trim(filename(1))
            Stop
        End If

        Rptr3 => ninvplninv(:, :, :, 3)
        Call Read_FITS_Real_3D(filename(10), Rptr3, stat)
        If (stat .Ne. 0) Then
            Print *, 'Error ', stat, ' while reading ', Trim(filename(0))
            Stop
        End If

        Rptr3 => ninvplninv(:, :, :, 4)
        Call Read_FITS_Real_3D(filename(11), Rptr3, stat)
        If (stat .Ne. 0) Then
            Print *, 'Error ', stat, ' while reading ', Trim(filename(1))
            Stop
        End If

#endif

        !------------------------------
        ! read in N^{-1} at res3
        !------------------------------

        Allocate(NinvQUr3(0:1535, 0:1535), Stat=Stat)
        If (stat .Ne. 0) Then
            Print *, 'Memory allocation error for NinvQUr3'
            Stop
        End If

        Rptr2 => NinvQUr3
        Call Read_FITS_Real_2D(filename(2), Rptr2, stat)
        If (stat .Ne. 0) Then
            Print *, 'Error ', stat, ' while reading ', Trim(filename(2))
            Stop
        End If

        !------------------------------
        ! read in maps at res3
        !------------------------------

        Allocate(w_r3(0:2*mp-1), m_r3(0:2*mp-1), p_r3(0:2*mp-1), Stat=Stat)
        Allocate(zzz(0:2*mp-1))
        If (stat .Ne. 0) Then
            Print *, 'Memory allocation error for w_r3, m_r3, or p_r3'
            Stop
        End If
        qfile = filename(3)
        Call READ_ARCHIVE_MAP(qfile, T, N, np, ReadStatus)
        If (ReadStatus /= 0) Then
            Print *, 'unable to read in ' // Trim(qfile)
            Stop
        End If

        Do ip = 0, mp - 1
            w_r3(ip) = T(ngood(ip)) * Mask_R3(ngood(ip))
        End Do

        ufile = filename(4)
        Call READ_ARCHIVE_MAP(ufile, T, N, np, ReadStatus)
        If (ReadStatus /= 0) Then
            Print *, 'unable to read in ' // Trim(ufile)
            Stop
        End If

        Do ip = 0, mp - 1
            w_r3(mp+ip) = T(ngood(ip)) * Mask_R3(ngood(ip))
        End Do

        Allocate(Dp0(0:2*mp-1, 0:2*mp-1), Stat=Stat)
        If (stat .Ne. 0) Then
            Print *, 'Memory allocation error for Dp0'
            Stop
        End If
        !--- original
        !  do ip=0,mp-1
        !     do jp=0,mp-1
        !--- RF
        Do jp = 0, mp - 1
            Do ip = 0, mp - 1
                !---
                Dp0(ip, jp) = NinvQUr3(ngood(ip), ngood(jp))
                Dp0(ip, mp+jp) = NinvQUr3(ngood(ip), np+ngood(jp))
                Dp0(mp+ip, jp) = NinvQUr3(np+ngood(ip), ngood(jp))
                Dp0(mp+ip, mp+jp) = NinvQUr3(np+ngood(ip), np+ngood(jp))
            End Do
        End Do

        !------------------------------
        ! read in FG templates at res3 [NO LONGER USED: 12/25/07, EK]
        !------------------------------

        Allocate(f_r3(0:2*mp-1), Stat=Stat)
        If (stat .Ne. 0) Then
            Print *, 'Memory allocation error for f_r3'
            Stop
        End If
        f_r3 = 0d0

        If (sig_temp .Ne. 0) Then

            Print *, 'Using foreground templates!!!'
            Print *, '----------------------------------------------------------------------'
            Stop

            qfile = filename(7)
            Call READ_ARCHIVE_MAP(qfile, T, N, np, ReadStatus)
            If (ReadStatus /= 0) Then
                Print *, 'unable to read in ' // Trim(qfile)
                Stop
            End If

            Do ip = 0, mp - 1
                f_r3(ip) = T(ngood(ip)) * Mask_R3(ngood(ip))
            End Do

            ufile = filename(8)
            Call READ_ARCHIVE_MAP(ufile, T, N, np, ReadStatus)
            If (ReadStatus /= 0) Then
                Print *, 'unable to read in ' // Trim(ufile)
                Stop
            End If

            Do ip = 0, mp - 1
                f_r3(mp+ip) = T(ngood(ip)) * Mask_R3(ngood(ip))
            End Do
        End If

        !------------------------------
        ! read in alm_tt
        !------------------------------
        Allocate(alm_tt(0:nlmax, 0:nlmax), Stat=Stat)
        If (stat .Ne. 0) Then
            Print *, 'Memory allocation error for alm_tt'
            Stop
        End If
        Call get_free_lun(lun)
        Open(lun, File=filename(5), Status='old')
        Do l = 0, nlmax
            Do m = 0, l
                Read(lun,*) alm_tt(l, m)
            End Do
        End Do
        Close(lun)

        !------------------------------
        ! read in Ninv Y
        !------------------------------
        Allocate(NinvYe(0:1535, 300), Stat=Stat)
        If (stat .Ne. 0) Then
            Print *, 'Memory allocation error for NinvY'
            Stop
        End If

        Cptr2 => NinvYe
        Call Read_FITS_Complex_2D_LM(filename(6), Cptr2, stat, IndFmt=2)
        If (stat .Ne. 0) Then
            Print *, 'Error ', stat, ' while reading ', Trim(filename(6))
            Stop
        End If

        Allocate(NinvYb(0:1535, 300), Stat=Stat)
        If (stat .Ne. 0) Then
            Print *, 'Memory allocation error for NinvY'
            Stop
        End If

        Cptr2 => NinvYb
        Call Read_FITS_Complex_2D_LM(filename(12), Cptr2, stat, IndFmt=2)
        If (stat .Ne. 0) Then
            Print *, 'Error ', stat, ' while reading ', Trim(filename(6))
            Stop
        End If

        !
        ! read in pixel window
        !
        Allocate(wl(0:nlmax))
        Call get_free_lun(lun)
        Open(lun, File=filename(9), Status='old')
        Do l = 0, nlmax
            Read(lun,*) wl(l)
        End Do
        Close(lun)

        Deallocate(T, N, Mask_R3)
        Deallocate(NinvQUr3)

#ifdef TIMING
        Call wmap_timing_end()
#endif

    End Subroutine tetbeebbeb_lowl_like_setup


    Function tetbeebbeb_pixlike_dof()
        Integer :: tetbeebbeb_pixlike_dof
        tetbeebbeb_pixlike_dof = 2 * mp
    End Function tetbeebbeb_pixlike_dof

    !===========================================
    Subroutine tetbeebbeb_lowl_likelihood(nlmaxin, clttin, cltein, cltbin, cleein, clbbin, clebin, chisq_r3, lndet)
        !=======================================

        Use wmap_util
        Use wmap_options, Only: teeebb_pixlike_lndet_offset

        Implicit None

        Real(8), Dimension(2:*), Intent(In) :: clttin, cltein, cleein, clbbin
        Real(8), Dimension(2:*), Intent(In) :: cltbin, clebin
        Real(8), Intent(Out) :: lndet, chisq_r3 ! like
        Integer, Intent(In) :: nlmaxin
#ifndef OPTIMIZE
        Real(8), Allocatable, Dimension(:, :) :: NinvSNinv
        Real(8), Allocatable, Dimension(:, :) :: CQU
#endif
        Real(8), External :: DDOT ! blas routine for dot products
        Real(8), Allocatable, Dimension(:, :) :: Dp
        Real(8), Allocatable, Dimension(:) :: clee, clbb, cltt, clte, cltb, cleb
        Integer :: ip, jp, nlmax, info, l, m, i, k, lun
        Integer :: t_start, t_end, crate, cmax
        Real :: Omega_pix

#ifdef TIMING
        Call wmap_timing_start('tetbeebbeb_lowl_likelihood')
#endif

        nlmax = 23
        Omega_pix = 3.14159 / (3.*8.**2.)
        If (nlmaxin .Ne. nlmax) Then
            Write(*,*) "need nlmax", nlmax, ", in tetbeebbeb likelihood, currently", nlmaxin
            Stop
        End If

        Allocate(cltt(0:nlmax), clte(0:nlmax), clee(0:nlmax), clbb(0:nlmax))
        Allocate(cltb(0:nlmax), cleb(0:nlmax))
        cltt(0:1) = 0.
        clte(0:1) = 0.
        clee(0:1) = 0.
        clbb(0:1) = 0.
        cltb(0:1) = 0.
        cleb(0:1) = 0.
        Do l = 2, nlmax
            cltt(l) = clttin(l) / Dble(l*(l+1)) * (2.*3.14159) * 1.d-6 * wl(l) ** 2.
            clte(l) = cltein(l) / Dble(l*(l+1)) * (2.*3.14159) * 1.d-6 * wl(l) ** 2.
            clee(l) = cleein(l) / Dble(l*(l+1)) * (2.*3.14159) * 1.d-6 * wl(l) ** 2.
            clbb(l) = clbbin(l) / Dble(l*(l+1)) * (2.*3.14159) * 1.d-6 * wl(l) ** 2.
            cltb(l) = cltbin(l) / Dble(l*(l+1)) * (2.*3.14159) * 1.d-6 * wl(l) ** 2.
            cleb(l) = clebin(l) / Dble(l*(l+1)) * (2.*3.14159) * 1.d-6 * wl(l) ** 2.
        End Do

        !------------------------------
        ! compute [N^{-1}S N^{-1} + N^{-1}]^{-1}
        !------------------------------
        Allocate(Dp(0:2*mp-1, 0:2*mp-1))

        lndet = 0d0

#ifdef OPTIMIZE
        !! MRN

        Do l = 2, nlmax
            xxx(l-1) = clee(l) - clte(l) ** 2. / cltt(l)
            xxx(l+nlmax-2) = clbb(l) - cltb(l) ** 2. / cltt(l)
            xxx(l+2*nlmax-3) = cleb(l) - clte(l) * cltb(l) / cltt(l)
            xxx(l+3*nlmax-4) = cleb(l) - cltb(l) * clte(l) / cltt(l)
        End Do

        Call DGEMV('N', mp*(2*mp+1), 4*(nlmax-1), 1.d0, ninvplninv2, &
            mp*(2*mp+1), xxx, 1, 0.d0, yyy, 1)

        k = 1
        ! --- original
        !        do ip = 0,2*mp-1
        !           do jp = ip,2*mp-1
        ! --- RF
        Do jp = 0, 2 * mp - 1
            Do ip = 0, jp
                ! ---
                Dp(ip, jp) = Dp0(ip, jp) + yyy(k)
                k = k + 1
            End Do
        End Do

#else

        !
        ! fill only the upper triangular part of N^{-1}SN^{-1}.
        ! add the foreground error term.
        !
        Allocate(NinvSNinv(0:2*mp-1, 0:2*mp-1))
        Allocate(CQU(0:2*mp-1, 0:2*mp-1))
        NinvSNinv = 0.
        ! --- original
        !  do ip=0,mp-1
        !     do jp=ip,mp-1
        !--- RF
        Do jp = 0, mp - 1
            Do ip = 0, jp
                !---
                NinvSNinv(ip, jp) = &
                    + DDOT(nlmax-1, clee(2:)-clte(2:)**2./cltt(2:), 1, Dble(ninvplninv(2:, ngood(ip), ngood(jp), 1)), 1) &
                    + DDOT(nlmax-1, clbb(2:)-cltb(2:)**2./cltt(2:), 1, Dble(ninvplninv(2:, ngood(ip), ngood(jp), 2)), 1) &
                    + DDOT(nlmax-1, cleb(2:)-clte(2:)*cltb(2:)/cltt(2:), 1, Dble(ninvplninv(2:, ngood(ip), ngood(jp), 3)), 1) &
                    + DDOT(nlmax-1, cleb(2:)-cltb(2:)*clte(2:)/cltt(2:), 1, Dble(ninvplninv(2:, ngood(ip), ngood(jp), 4)), 1)

                NinvSNinv(ip, mp+jp) = &
                    + DDOT(nlmax-1, clee(2:)-clte(2:)**2./cltt(2:), 1, Dble(ninvplninv(2:, ngood(ip), np+ngood(jp), 1)), 1) &
                    + DDOT(nlmax-1, clbb(2:)-cltb(2:)**2./cltt(2:), 1, Dble(ninvplninv(2:, ngood(ip), np+ngood(jp), 2)), 1) &
                    + DDOT(nlmax-1, cleb(2:)-clte(2:)*cltb(2:)/cltt(2:), 1, Dble(ninvplninv(2:, ngood(ip), np+ngood(jp), 3)), 1) &
                    + DDOT(nlmax-1, cleb(2:)-cltb(2:)*clte(2:)/cltt(2:), 1, Dble(ninvplninv(2:, ngood(ip), np+ngood(jp), 4)), 1)

                NinvSNinv(mp+ip, mp+jp) = &
                    + DDOT(nlmax-1, clee(2:)-clte(2:)**2./cltt(2:), 1, Dble(ninvplninv(2:, np+ngood(ip), np+ngood(jp), 1)), 1) &
                    + DDOT(nlmax-1, clbb(2:)-cltb(2:)**2./cltt(2:), 1, Dble(ninvplninv(2:, np+ngood(ip), np+ngood(jp), 2)), 1) &
                    + DDOT(nlmax-1, cleb(2:)-clte(2:)*cltb(2:)/cltt(2:), 1, Dble(ninvplninv(2:, np+ngood(ip), np+ngood(jp), 3)), 1) &
                    + DDOT(nlmax-1, cleb(2:)-cltb(2:)*clte(2:)/cltt(2:), 1, Dble(ninvplninv(2:, np+ngood(ip), np+ngood(jp), 4)), 1)
            End Do
            ! --- modified since there was only one loop in ip
        End Do
        !   do ip=0,mp-1
        !     do jp=0,ip-1
        Do jp = 0, mp - 1
            Do ip = jp + 1, mp - 1

                NinvSNinv(ip, mp+jp) = NinvSNinv(ip, mp+jp) &
                    + DDOT(nlmax-1, clee(2:)-clte(2:)**2./cltt(2:), 1, Dble(ninvplninv(2:, ngood(ip), np+ngood(jp), 1)), 1) &
                    + DDOT(nlmax-1, clbb(2:)-cltb(2:)**2./cltt(2:), 1, Dble(ninvplninv(2:, ngood(ip), np+ngood(jp), 2)), 1) &
                    + DDOT(nlmax-1, cleb(2:)-clte(2:)*cltb(2:)/cltt(2:), 1, Dble(ninvplninv(2:, ngood(ip), np+ngood(jp), 3)), 1) &
                    + DDOT(nlmax-1, cleb(2:)-cltb(2:)*clte(2:)/cltt(2:), 1, Dble(ninvplninv(2:, ngood(ip), np+ngood(jp), 4)), 1)
            End Do

        End Do

        Dp = Dp0 + NinvSNinv

        Deallocate(NinvSNinv)

#endif

#ifdef TIMING
        Call wmap_timing_checkpoint('finished Dp')
#endif

        Call DPOTRF('U', 2*mp, Dp, 2*mp, info)
        If (info .Ne. 0) Then
            !call wmap_likelihood_error( 'tetbeebbeb: bad dpotrf', info )
            !chisq_r3 = 0d0
            !lndet = 0d0
            chisq_r3 = 1d10
            lndet = 0d0
            Print *, 'dpotrf failed, info = ', info
#ifdef TIMING
            Call wmap_timing_end()
#endif
            Call get_free_lun(lun)
            !Open(lun, File='debug.txt', Status='unknown', Action='write')
            !Do l = 2, 23
            !   Write(lun, '(I,6ES)') l, cltt(l), clte(l), cltb(l), clee(l), clbb(l), cleb(l)
            !   Write(*, '(I,6ES)') l, cltt(l), clte(l), cltb(l), clee(l), clbb(l), cleb(l)
            !End Do
            !Close(lun)
            Call wmap_likelihood_error('tetbeebbeb: bad dpotrf', info)
!!$        stop
            Return
        End If

#ifdef TIMING
        Call wmap_timing_checkpoint('finished spotrf')
#endif

        Do ip = 0, 2 * mp - 1
            lndet = lndet + 2. * Log(Real(Dp(ip, ip)))
        End Do

#ifndef OPTIMIZE
        Call DPOTRI('U', 2*mp, Dp, 2*mp, info)
#endif

#ifdef TIMING
        Call wmap_timing_checkpoint('finished dpotri')
#endif

        If (info .Ne. 0) Then
            Call wmap_likelihood_error('tetbeebbeb: bad dpotri', info)
            chisq_r3 = 0d0
            lndet = 0d0
            Return
        End If

#ifndef OPTIMIZE
        CQU(:, :) = Dp
        Deallocate(Dp)
#endif


        !-----------------------------------
        ! calculate the predicted QU at res3
        !-----------------------------------
        p_r3 = 0.
!!! CHECK NinvY [which element to use for cltb?]
        Do ip = 0, mp - 1
            i = 3
            Do l = 2, 23
                i = i + 1
                p_r3(ip) = p_r3(ip) &
                    + clte(l) / cltt(l) * wl(l) * alm_tt(l, 0) * NinvYe(ngood(ip), i) &
                    + cltb(l) / cltt(l) * wl(l) * alm_tt(l, 0) * NinvYb(ngood(ip), i)
                p_r3(ip+mp) = p_r3(ip+mp) &
                    + clte(l) / cltt(l) * wl(l) * alm_tt(l, 0) * NinvYe(ngood(ip)+np, i) &
                    + cltb(l) / cltt(l) * wl(l) * alm_tt(l, 0) * NinvYb(ngood(ip)+np, i)
                Do m = 1, l
                    i = i + 1
                    p_r3(ip) = p_r3(ip) &
                        + clte(l) / cltt(l) * wl(l) * (alm_tt(l, m)*NinvYe(ngood(ip), i) &
                        + Conjg(alm_tt(l, m)*NinvYe(ngood(ip), i))) &
                        + cltb(l) / cltt(l) * wl(l) * (alm_tt(l, m)*NinvYb(ngood(ip), i) &
                        + Conjg(alm_tt(l, m)*NinvYb(ngood(ip), i)))
                    p_r3(ip+mp) = p_r3(ip+mp) &
                        + clte(l) / cltt(l) * wl(l) * (alm_tt(l, m)*NinvYe(ngood(ip)+np, i) &
                        + Conjg(alm_tt(l, m)*NinvYe(ngood(ip)+np, i))) &
                        + cltb(l) / cltt(l) * wl(l) * (alm_tt(l, m)*NinvYb(ngood(ip)+np, i) &
                        + Conjg(alm_tt(l, m)*NinvYb(ngood(ip)+np, i)))
                End Do
            End Do
        End Do

#ifdef OPTIMIZE

        m_r3 = w_r3 - p_r3
        Call DPOTRS('U', 2*mp, 1, Dp, 2*mp, m_r3, 2*mp, info)
	!chisq_r3 = DDOT(2*mp,m_r3,1,w_r3-p_r3,1)
        zzz = w_r3 - p_r3
        chisq_r3 = Sum(m_r3*zzz)
#else

        Call DSYMV('U', 2*mp, 1.d0, CQU(:, :), 2*mp, w_r3-p_r3, 1, 0.d0, m_r3, 1)
        chisq_r3 = DDOT(2*mp, m_r3, 1, w_r3-p_r3, 1)

        Deallocate(CQU)

#endif

        chisq_r3 = chisq_r3 / 2d0
        lndet = (lndet-teeebb_pixlike_lndet_offset) / 2d0

#ifdef TIMING
        Call wmap_timing_end()
#endif

    End Subroutine tetbeebbeb_lowl_likelihood

End Module WMAP_tetbeebbeb_lowl
