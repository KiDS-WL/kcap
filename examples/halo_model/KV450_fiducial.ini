[DEFAULT]
CSL_PATH = .
KCAP_PATH = .
RUN_NAME = test
OUTPUT_DIR = examples/halo_model/output/KV450
;;; halo model defaults
nz_def = 20
zmin_def =  0.0
zmax_def = 6.0
nmass_def = 200
logmassmin_def = 9.0
logmassmax_def = 16.0


[runtime]
sampler = test ;metropolis

[pipeline]
modules = sample_ln_As one_parameter_hmcode camb extrapolate_power hmf_and_halo_bias hod nfw_halo centrals_alignment satellites_alignment radial_satellite_alignment pk load_nz source_photoz_bias projection add_intrinsic cl2xi derived_parameters mini_2pt_like

values = examples/halo_model/KV450_values.ini
priors = examples/halo_model/KV450_priors.ini

likelihoods = mini_2pt_like
extra_output = cosmological_parameters/omega_m cosmological_parameters/A_s cosmological_parameters/sigma_8 cosmological_parameters/S8 cosmological_parameters/h0 cosmological_parameters/cosmomc_theta
quiet=F
timing=T
debug=F

[metropolis]
samples = 10000
nsteps = 1

[multinest]
;wrapped_params = cosmological_parameters--omega_b   cosmological_parameters--h0
max_iterations=100000
multinest_outfile_root=%(OUTPUT_DIR)s/multinest_%(RUN_NAME)s_
resume=F
; from Joe:- For a quick run:
live_points=250
efficiency=0.8
tolerance=0.1
constant_efficiency=F
;    ~ 140k evaluations
;    ~ 9k independent samples
;    Few enough samples that the plots will be too scrappy to use in publications. 
;    Estimated mean and covmat will still be good to a few percent
;    Evidence will be a bit off compared to other estimates.
;- Suggested standard run:
;live_points=500
;efficiency=0.3
;tolerance=0.1
;constant_efficiency=F
;    ~ 350k evaluations
;    ~ 20k independent samples
;    Plots should be fine with some small smoothing or Schuhman's transformation.
;    Reasonable evidence
;- A mega-run:
;live_points=1000
;efficiency=0.05
;tolerance=0.1   
;constant_efficiency=T
;    ~ 1M evaluations
;    ~ 40k independent samples
;    Switching on constant_efficiency speeds up from ~1M samples to ~600k
;    Should only need one or two of these for comparison.

;KV450 fiducial set up
;live_points=1000
;efficiency=0.3
;tolerance=0.5
;constant_efficiency=F
;ins=F

[emcee]
; The emcee sampler uses the concept of walkers, a collection
; ; of live points.  Sampling is done along lines that connect
; ; pairs of walkers.  The number of walkers must be at least
; ; 2*nparam + 1, but in general more than that usually works
; ; better.
burn=0.3
walkers = 72
; ; This many samples is overkill, just to make the plots
; ; look a lot nicer
samples = 10000
;;1000000
; ; This is the interval at which convergence diagnostics
; ; are performed
nsteps = 5
;

[test]
save_dir=%(OUTPUT_DIR)s/output_%(RUN_NAME)s
fatal_errors=T

[output]
filename=%(OUTPUT_DIR)s/samples_%(RUN_NAME)s.txt
format=text

[consistency]
file = %(CSL_PATH)s/cosmosis-standard-library/utility/consistency/consistency_interface.py

[sample_ln_As]
file = %(KCAP_PATH)s/utils/sample_ln_As.py

[derived_parameters]
file = %(KCAP_PATH)s/utils/derived_parameters.py
parameters = S8

[one_parameter_hmcode]
file = %(KCAP_PATH)s/utils/one_parameter_hmcode.py
a_0 = 0.98
a_1 = -0.12

[camb]
file = %(CSL_PATH)s/cosmosis-standard-library/boltzmann/pycamb/camb_interface.py
mode=transfer
lmax=2500
do_reionization = F
;accuracy_boost = 2.0
;high_accuracy_default = T
feedback=0
kmax=20.0
zmin=0.0
zmid=2.0
nz_mid=100
zmax=6.0
nz=150
background_zmax=6.0
background_zmin=0.0
background_nz=6000
halofit_verion=mead
theta_H0_range=10 150

[sigma8_rescale]
file = %(CSL_PATH)s/cosmosis-standard-library/utility/sample_sigma8/sigma8_rescale.py

[load_nz]
file = %(CSL_PATH)s/cosmosis-standard-library/number_density/load_nz/load_nz.py
filepath = %(KCAP_PATH)s/data/KV450/nofz/Nz_DIR_z0.1t0.3.asc %(KCAP_PATH)s/data/KV450/nofz/Nz_DIR_z0.3t0.5.asc %(KCAP_PATH)s/data/KV450/nofz/Nz_DIR_z0.5t0.7.asc %(KCAP_PATH)s/data/KV450/nofz/Nz_DIR_z0.7t0.9.asc %(KCAP_PATH)s/data/KV450/nofz/Nz_DIR_z0.9t1.2.asc
histogram = True
output_section = nz_KV450_5bin

[source_photoz_bias]
file = %(CSL_PATH)s/cosmosis-standard-library/number_density/photoz_bias/photoz_bias.py
mode = additive
sample = nz_KV450_5bin
bias_section = nofz_shifts
interpolation = linear

[linear_alignment]
file = %(CSL_PATH)s/cosmosis-standard-library/intrinsic_alignments/la_model/linear_alignments_interface.py
method = bk_corrected

[projection]
file = %(CSL_PATH)s/cosmosis-standard-library/structure/projection/project_2d.py
ell_min = 0.1
ell_max = 5.0e5
n_ell = 400
shear-shear = KV450_5bin-KV450_5bin 
shear-intrinsic = KV450_5bin-KV450_5bin
intrinsic-intrinsic = KV450_5bin-KV450_5bin
verbose = T
get_kernel_peaks = F


[add_intrinsic]
file=%(CSL_PATH)s/cosmosis-standard-library/shear/add_intrinsic/add_intrinsic.py
position-shear=False

;This Nicaea code converts C_ell into xi(theta).
;It is fast and accurate but requires a high ell_max, as shown above
[cl2xi]
file = %(CSL_PATH)s/cosmosis-standard-library/shear/cl_to_xi_nicaea/nicaea_interface.so
corr_type = 0


;[2pt_like]
;file = %(CSL_PATH)s/cosmosis-standard-library/likelihood/2pt/2pt_like.py
;data_file=%(CSL_PATH)s/cosmosis-standard-library/likelihood/cfhtlens/cfhtlens_heymans13.fits
;gaussian_covariance=F
;covmat_name=COVMAT
;covariance_realizations = 1656
;like_name=cfhtlens

;data_sets=all
;data_sets = xi_plus xi_minus

[extrapolate_power]
file=%(CSL_PATH)s/cosmosis-standard-library/boltzmann/extrapolate/extrapolate_power.py
kmax=500.0

[mini_2pt_like]
file = %(KCAP_PATH)s/utils/mini_2pt_like.py
n_bin = 5
data_filename = %(KCAP_PATH)s/data/KV450/data_vector/KV450_reweight_3x4x4_v2_good_xipm_mcor_5bin.dat
angular_binning_mode = integrate
;9 log-spaced bins between 0.5 and 300.0
angular_bin_edges = 0.5 1.01777898 2.0717481 4.21716333 8.58428037 17.4738002 35.56893304 72.40262468 147.37973879 300.0
cut_xi_plus = 7 8
cut_xi_minus = 0 1 2
order_cov = montepython
order_data = montepython
cov = %(KCAP_PATH)s/data/KV450/covariance/cov_analytic_montepython_mcorr.txt
m_correction = -0.0128 -0.0104 -0.0114 0.0072 0.0061
constant_c_offset = T
xi_pm_c_file = %(KCAP_PATH)s/data/KV450/systematics/KV450_ALL_c12_treecorr.out
like_name = mini_2pt_like
keep_theory_vector = T

[cosebis]
file = %(CSL_PATH)s/cosebis/libcosebis_likelihood.so
theta_min = 0.5
theta_max = 300.0
n_max = 5
input_cosebis_filename = %(KCAP_PATH)s/examples/kv450_data/data_vector/En_20_0.50-300.00_5.bin
input_covariance_filename = %(KCAP_PATH)s/examples/kv450_data/cov/CEnMixed_Th_FromInputNpair_weighted_KV450_20_0.50-300.00_5.ascii

;;;; Halo model modules
[hmf_and_halo_bias]
file = %(KCAP_PATH)s/halo_model/dev/v3/hmf_and_hbf_tinker.py
log_mass_min = %(logmassmin_def)s
log_mass_max = %(logmassmax_def)s
nmass = %(nmass_def)s
zmin= %(zmin_def)s
zmax= %(zmax_def)s
nz= %(nz_def)s 
do_halo_bias = True

[hod]
file = %(KCAP_PATH)s/halo_model/dev/v3/hod_interface_v2.py
; if luminosities_z = True, then the luminosities are read from the luminosities_file [z_mid, lum_min(z), lum_max(z)]
luminosities_z = False 
luminosities_file = /your/path/to/file.txt
nlum = 200
; -
; lum_min, lum_max, zmin, zmax and nz are only needed if luminosities_z = False
; -
lum_min = 4.698941e+08
lum_max = 1.180321e+11
zmin = %(zmin_def)s
zmax = %(zmax_def)s
nz = %(nz_def)s 
abs_mag_sun = 4.68
log_mass_min = %(logmassmin_def)s
log_mass_max = %(logmassmax_def)s
nmass = %(nmass_def)s
z_median = 0.4
do_hod = True
do_number_density = True
do_galaxy_linear_bias = True
do_luminosity_function = False
; options are: "lf_z" or "lf_zmed" depending if you want to calculate the LF per each redshift or on the median one
lf_mode = "lf_z"
do_clf_quantities = False
name =

[nfw_halo]
file = %(KCAP_PATH)s/halo_model/dev/v3/nfw_halo.py
zmin = %(zmin_def)s
zmax = %(zmax_def)s
nz = %(nz_def)s
log_mass_min = %(logmassmin_def)s
log_mass_max = %(logmassmax_def)s
nmass = 20
nmass_fast =

[centrals_alignment]
file = %(KCAP_PATH)s/halo_model/dev/v3/ia_amplitudes_all_models.py
galaxy_type = centrals
; if galaxy_type = centrals, then the choices are : 'None', 'Joachimi2011' (single power law), 'double_powerlaw'
luminosity_dependence='None'
z_loglum_file= /path/to/redcen_lum.fits ; a fits file containing the columns 'z' and 'loglum' 
zmin= %(zmin_def)s
zmax= %(zmax_def)s
nz = %(nz_def)s
name =

[satellites_alignment]
file = %(KCAP_PATH)s/halo_model/dev/v3/ia_amplitudes_all_models.py
galaxy_type = satellites
; if galaxy_type = satellites, then the choices are : 'None', 'satellite_luminosity_dependence' (power law)
luminosity_dependence='None'
z_loglum_file= /path/to/redsat_lum.fits
zmin= %(zmin_def)s
zmax= %(zmax_def)s
nz = %(nz_def)s
name =

[radial_satellite_alignment]
file = %(KCAP_PATH)s/halo_model/dev/v3/wkm_interp_interface_v3_eps.py
zmin = %(zmin_def)s
zmax = %(zmax_def)s
nz = %(nz_def)s
log_mass_min = %(logmassmin_def)s
log_mass_max = %(logmassmax_def)s
nmass = %(nmass_def)s
kmin = 0.1
kmax = 1000.
nk = 1000
name=

[pk]
file= %(KCAP_PATH)s/halo_model/dev/v3/pk_interface_v3.py
;log-spaced mass in units of M_sun/h
log_mass_min = %(logmassmin_def)s
log_mass_max = %(logmassmax_def)s
nmass = %(nmass_def)s
zmin = %(zmin_def)s
zmax = %(zmax_def)s
nz = %(nz_def)s
; still need to implement this - leave False
pipeline = False
p_GG = False
p_nn = False
p_xgG = False
p_gI = False
p_xGI = True
p_II = True
two_halo_only = False
hod_section_name = hod
name =
